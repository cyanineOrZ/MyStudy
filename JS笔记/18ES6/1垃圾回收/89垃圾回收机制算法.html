<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 浏览器常用的垃圾回收方法有两种， 标记清除 和 引用计数

        // 垃圾回收算法，就是垃圾收集器按照固定的时间间隔，周期性地寻找那些不再使用的变量，然后将其清除并释放内存
    </script>


    <script>
        // 将内存看为一个长方形， 被引用对象【包括变量，函数，对象等】在内存中被创建或者被调用时，会在内存中产生一块属于该被引用对象的空间。
        // 如果该空间被垃圾回收机制回收并释放， 则表示该被引用变量以及完成工作，这个过程与内存分配的生命周期类似。
    </script>


    <script>
        // 一、标记清除

        // 大多数浏览器常用的方法

        // 垃圾回收器将定期从根（root）的对象开始，找寻所有被引用的对象，将不再被使用引用对象进行标记，在扫描完全部被引用对象后，对被标记的引用对象进行内存释放

        // 优点
        // 1、简单，被引用对象只有被标记和没有被标记两种状态。

        // 缺点
        // 1、标记清除法会隔一段时间就对内存中所有变量进行一次扫描，效率较低但解决了循环引用的问题
        // 2、在标记清除法释放内存后， 剩余的被引用对象的内存位置是保存不变的， 就会造成内存碎片的问题，在新建被引用对象的时候会有影响。
    </script>

    <script>
        // 二、引用计数

        // IE浏览器采用的垃圾回收机制便是引用计数法。

        // 引用技术就是跟踪记录每个值被引用的次数， 当变量被声明并赋予了一个值给该变量时， 这个值的引用次数+1
        // 相反，当包含了这个值的引用的变量被赋予或取得了另一只值， 则这个值的引用次数-1，当这个值的引用次数=0时，则表示没有变量指向该值， 则该值占据的内存会被垃圾回收机制回收
    
        // 引用计数法的一大问题就是当遇到循环引用时， 引用计数无法对循环引用做出合理判断，在循环引用中，值的引用次数永远大于等于2，即使作用域结束，值仍被变量引用，
        // 值的引用次数永远不会是0， 也就永远不会被回收
        function test() {
            const a = {}
            const b = {}
            a.t = b
            b.t = a
            // 这便造成了循环引用的问题， a引用b， b引用a
        }
    </script>

    <script>
        // 三、标记整理(Mark-Compact) 标记标记清除算法的改进版

        // 标记整理在垃圾清除阶段的整体阶段与标记清除法一样， 但在释放内存后，会将存活的被引用对象向内存一端进行移动， 让剩余的被引用对象靠在一起， 解决了内存碎片的问题。

        // 标记整理法释放内存后，存活的被引用对象的内存位置有可能发生改变。
    </script>
</body>
</html>